<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>FlowGraph - Lit Example</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html, body {
    height: 100%; 
    margin: 0; 
    font-family: 'Inter', 'Roboto', system-ui, sans-serif; 
    color: #fff;
    overflow: hidden;
  }
  
  #app {
    position: relative; 
    height: 100vh; 
    width: 100vw; 
    overflow: hidden; 
    display: flex;
  }

  flow-context-menu {
    --context-menu-min-width: 300px;
    --context-menu-max-width: 450px;
  }
  
  /* Example: Custom animation colors and speeds (commented out to show default orange theme) */
  /*
  flow-graph {
    --fg-animation-flowing-color: #00ff88;
    --fg-animation-pulsing-color: #ff6b00;
    --fg-animation-data-flow-color: #8b5cf6;
    --fg-animation-speed-normal: 1s;
    --fg-trail-opacity: 0.9;
  }
  */
  
  /* Example: Custom socket styling (commented out to show default) */
  /*
  flow-graph {
    --fg-socket-size: 18px;
    --fg-socket-border-width: 3px;
    --fg-socket-scale-hover: 1.2;
    --fg-socket-input-border: rgba(59,130,246,0.8);
    --fg-socket-output-border: rgba(147,51,234,0.8);
  }
  */
  
  /* Custom Solid Node Styles - Override bundled CSS */
  .node-solid {
    border-radius: 6px !important;
    background: #ffffff !important;
    border: 3px solid #1f2937;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    color: #1f2937 !important;
    opacity: 1 !important;
    backdrop-filter: none !important;
  }

  .node-solid .input-box {
    background: #f9fafb !important;
    border: 2px solid #d1d5db !important;
    color: #1f2937 !important;
    font-weight: 500 !important;
  }

  .node-solid .input-box:focus {
    border-color: #1f2937 !important;
    background: #ffffff !important;
    box-shadow: 0 0 0 3px rgba(31, 41, 55, 0.1) !important;
  }

  /* Auto-expanding textbox */
  .node-solid .auto-expand {
    resize: none !important;
    overflow: hidden !important;
    transition: width 0.2s ease !important;
    min-width: 200px !important;
    max-width: 400px !important;
  }

  /* Make the node container flexible */
  .node-solid {
    min-width: 200px !important;
    width: auto !important;
    max-width: 450px !important;
    transition: width 0.2s ease !important;
  }

  .node-solid .body {
    width: auto !important;
    min-width: 200px !important;
    transition: width 0.2s ease !important;
  }
  </style>
  <!-- Use bundled FlowGraph with CSS -->
  <link rel="stylesheet" href="dist/flowgraph.css">
  <script type="module" src="dist/flowgraph.es.js"></script>
</head>
<body>
  <div id="app">
    <!-- Graph execution controls -->
    <div style="position: absolute; top: 10px; left: 10px; z-index: 1000; display: flex; gap: 10px;">
      <button id="execute-graph-btn" style="
        padding: 8px 16px;
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
      " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        üöÄ Execute Graph
      </button>
      
      <!-- Animation Controls -->
      <div style="
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 8px 12px;
        background: rgba(0,0,0,0.7);
        border-radius: 6px;
        border: 1px solid rgba(124,58,237,0.3);
      ">
        <label style="font-size: 12px; color: #94a3b8;">Animation:</label>
        <select id="animation-style" style="
          padding: 4px 8px;
          background: rgba(15,23,36,0.8);
          color: white;
          border: 1px solid rgba(124,58,237,0.5);
          border-radius: 4px;
          font-size: 12px;
        ">
          <option value="flowing">Flowing</option>
          <option value="pulsing">Pulsing</option>
          <option value="data-flow">Data Flow</option>
        </select>
        <select id="animation-speed" style="
          padding: 4px 8px;
          background: rgba(15,23,36,0.8);
          color: white;
          border: 1px solid rgba(124,58,237,0.5);
          border-radius: 4px;
          font-size: 12px;
        ">
          <option value="slow">Slow</option>
          <option value="normal" selected>Normal</option>
          <option value="fast">Fast</option>
        </select>
        <button id="toggle-animations" style="
          padding: 4px 8px;
          background: linear-gradient(135deg, #7c3aed, #5b21b6);
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 12px;
          cursor: pointer;
        ">Enable</button>
        <button id="clear-trail" style="
          padding: 4px 8px;
          background: linear-gradient(135deg, #6b7280, #4b5563);
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 12px;
          cursor: pointer;
        ">Clear Trail</button>
        <button id="reset-colors" style="
          padding: 4px 8px;
          background: linear-gradient(135deg, #10b981, #059669);
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 12px;
          cursor: pointer;
        ">Reset Colors</button>
        <button id="save-graph" style="
          padding: 4px 8px;
          background: linear-gradient(135deg, #3b82f6, #1d4ed8);
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 12px;
          cursor: pointer;
        ">Save Graph</button>
      <button id="load-graph" style="
        padding: 4px 8px;
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
      ">Load Graph</button>
      <button id="toggle-readonly" style="
        padding: 4px 8px;
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
      ">Readonly Mode</button>
      </div>
      
      <!-- Trail Duration Control -->
      <div style="
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 8px 12px;
        background: rgba(0,0,0,0.7);
        border-radius: 6px;
        border: 1px solid rgba(245,158,11,0.3);
      ">
        <label style="font-size: 12px; color: #94a3b8;">Trail Duration:</label>
        <select id="trail-duration" style="
          padding: 4px 8px;
          background: rgba(15,23,36,0.8);
          color: white;
          border: 1px solid rgba(245,158,11,0.5);
          border-radius: 4px;
          font-size: 12px;
        ">
          <option value="0">Infinite</option>
          <option value="1000">1 second</option>
          <option value="3000">3 seconds</option>
          <option value="5000" selected>5 seconds</option>
          <option value="10000">10 seconds</option>
        </select>
      </div>
      <div style="
        padding: 8px 12px;
        background: rgba(0,0,0,0.7);
        color: #10b981;
        border-radius: 6px;
        font-size: 12px;
        font-family: monospace;
        border: 1px solid rgba(16,185,129,0.3);
      ">
        Shift+Enter
      </div>
    </div>
    
    <flow-graph theme="dark" snap-to-grid grid-size="20">
      <flow-definitions>
        <!-- Number Input Node -->
        <flow-node-def name="data.number" label="Number" width="160" height="100" category="Data" description="Outputs a numeric value" icon="üî¢" 
                       color-bg="linear-gradient(90deg, rgba(59,130,246,0.15), transparent)" color-text="#3b82f6" onExecute="loadData">
          <node-body>
            <div class="title">üî¢ Number</div>
            <div class="body">
              <input type="number" class="input-box" value="0" data-key="num:value" placeholder="Enter value" style="width: calc(100% - 10px);">
              <flow-socket type="output" name="value" label="Value" data-type="number" color="deeppink"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Math Add Node -->
        <flow-node-def name="math.add" label="Add" width="180" height="120" category="Math" description="Adds two numbers together" icon="‚ûï" 
                       color-bg="linear-gradient(90deg, rgba(245,158,11,0.15), transparent)" color-text="#f59e0b" onExecute="addNumbers">
          <node-body>
            <div class="title">‚ûï Add</div>
            <div class="body">
              <flow-socket type="input" name="a" label="A" data-type="number" max-connection="1"></flow-socket>
              <flow-socket type="input" name="b" label="B" data-type="number" max-connection="1"></flow-socket>
              <div style="height:8px"></div>
              <flow-socket type="output" name="sum" label="Sum" data-type="number" color="#f59e0b" max-connection="3"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Watch Node -->
        <flow-node-def name="data.watch" label="Watch" width="160" height="100" category="Data" description="Displays input value" icon="üëÅÔ∏è" onExecute="watchValue">
          <node-body>
            <div class="title">üëÅÔ∏è Watch</div>
            <div class="body">
              <flow-socket type="input" name="value" label="Value" data-type="any"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Multiply Node -->
        <flow-node-def name="math.multiply" label="Multiply" width="180" height="120" category="Math" description="Multiplies two numbers" icon="‚úñÔ∏è" onExecute="multiplyNumbers">
          <node-body>
            <div class="title">‚úñÔ∏è Multiply</div>
            <div class="body">
              <flow-socket type="input" name="a" label="A" data-type="number" max-connection="1"></flow-socket>
              <flow-socket type="input" name="b" label="B" data-type="number" max-connection="1"></flow-socket>
              <div style="height:8px"></div>
              <flow-socket type="output" name="product" label="Product" data-type="number" color="#8b5cf6" max-connection="2"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Split Node -->
        <flow-node-def name="util.split" label="Split" width="160" height="140" category="Utility" description="Splits input into two outputs" icon="üîÄ" onExecute="splitValue">
          <node-body>
            <div class="title">üîÄ Split</div>
            <div class="body">
              <flow-socket type="input" name="input" label="Input" data-type="any" max-connection="1"></flow-socket>
              <div style="height:8px"></div>
              <flow-socket type="output" name="out1" label="Out 1" data-type="any" max-connection="5"></flow-socket>
              <flow-socket type="output" name="out2" label="Out 2" data-type="any" max-connection="5"></flow-socket>
              <flow-socket type="output" name="out3" label="Out 3" data-type="any" max-connection="5"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Advanced 3D Renderer Node - Shows arbitrary HTML content with data-draggable attributes -->
        <flow-node-def name="render.3d" label="3D Renderer" width="320" height="280" category="Render" description="Advanced 3D rendering with controls" icon="üé®" onExecute="render3D">
          <node-body>
            <div class="title">üéÆ 3D Renderer</div>
            <div class="body">
              <!-- Input sockets -->
              <flow-socket type="input" name="mesh" label="Mesh Data" data-type="object"></flow-socket>
              <flow-socket type="input" name="camera" label="Camera" data-type="object"></flow-socket>
              
              <!-- 3D Canvas (simulated) -->
              <div style="margin: 8px 0; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; background: linear-gradient(45deg, #1a1a2e, #16213e); height: 120px; position: relative; overflow: hidden;">
                <canvas width="280" height="110" style="width: 100%; height: 100%; cursor: grab;" data-draggable="false"></canvas>
                <div style="position: absolute; top: 4px; right: 4px; font-size: 10px; color: rgba(255,255,255,0.5);">WebGL</div>
                <div style="position: absolute; bottom: 4px; left: 4px; font-size: 10px; color: rgba(255,255,255,0.5);">FPS: 60</div>
              </div>
              
              <!-- Various control types -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 8px 0;">
                <div>
                  <label style="font-size: 10px; color: rgba(255,255,255,0.7);">Rotation X:</label>
                  <input type="range" min="0" max="360" value="45" data-draggable="false" style="width: 100%; accent-color: #10b981;">
                </div>
                <div>
                  <label style="font-size: 10px; color: rgba(255,255,255,0.7);">Rotation Y:</label>
                  <input type="range" min="0" max="360" value="30" data-draggable="false" style="width: 100%; accent-color: #10b981;">
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin: 4px 0;">
                <select class="input-box" data-draggable="false" style="font-size: 11px;">
                  <option>Perspective</option>
                  <option>Orthographic</option>
                  <option>Isometric</option>
                </select>
                <input type="color" value="#10b981" data-draggable="false" style="width: 100%; height: 24px; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; background: transparent;">
              </div>
              
              <div style="margin: 4px 0;">
                <textarea class="input-box" data-draggable="false" placeholder="Shader code..." rows="2" style="resize: vertical; font-family: monospace; font-size: 10px;"></textarea>
              </div>
              
              <div style="display: flex; gap: 4px; margin: 4px 0;">
                <button data-draggable="false" style="flex: 1; padding: 4px 8px; background: rgba(16,185,129,0.2); border: 1px solid #10b981; color: #10b981; border-radius: 4px; font-size: 10px; cursor: pointer;">Render</button>
                <button data-draggable="false" style="flex: 1; padding: 4px 8px; background: rgba(239,68,68,0.2); border: 1px solid #ef4444; color: #ef4444; border-radius: 4px; font-size: 10px; cursor: pointer;">Reset</button>
              </div>
              
              <!-- Output sockets -->
              <div style="height:8px"></div>
              <flow-socket type="output" name="render" label="Rendered" data-type="texture"></flow-socket>
              <flow-socket type="output" name="stats" label="Stats" data-type="object"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Logic Node -->
        <flow-node-def name="logic.if" label="If" width="160" height="120" category="Logic" description="Conditional logic" icon="‚ö°" 
                       color-bg="linear-gradient(90deg, rgba(239,68,68,0.15), transparent)" color-text="#ef4444" onExecute="conditionalLogic">
          <node-body>
            <div class="title">‚ö° If</div>
            <div class="body">
              <flow-socket type="input" name="condition" label="Condition" data-type="any"></flow-socket>
              <div style="height:8px"></div>
              <flow-socket type="output" name="true" label="True" data-type="any" color="#10b981"></flow-socket>
              <flow-socket type="output" name="false" label="False" data-type="any" color="#ef4444"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Text Node -->
        <flow-node-def name="text.string" label="String" width="160" height="100" category="Text" description="Text input/output" icon="üìù" 
                       color-bg="linear-gradient(90deg, rgba(59,130,246,0.15), transparent)" color-text="#3b82f6" onExecute="processString">
          <node-body>
            <div class="title">üìù String</div>
            <div class="body">
              <input type="text" class="input-box" value="Hello" data-key="text:value" placeholder="Enter text">
              <flow-socket type="output" name="text" label="Text" data-type="string"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Canvas Node -->
        <flow-node-def name="render.canvas" label="Canvas" width="200" height="150" category="Render" description="2D Canvas renderer" icon="üé®" 
                       color-bg="linear-gradient(90deg, rgba(139,92,246,0.15), transparent)" color-text="#8b5cf6" onExecute="renderCanvas">
          <node-body>
            <div class="title">üé® Canvas</div>
            <div class="body">
              <canvas data-draggable="false" style="width: 100%; height: 60px; background: #000; border-radius: 4px;"></canvas>
              <flow-socket type="output" name="image" label="Image" data-type="image"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Example Node with Custom Socket Styling -->
        <flow-node-def name="example.custom" label="Custom Socket Example" width="180" height="120" category="Example" description="Shows custom socket styling" icon="üé®" onExecute="customExample">
          <node-body>
            <div class="title">üé® Custom Socket Example</div>
            <div class="body">
              <!-- Default socket -->
              <flow-socket type="input" name="default" label="Default Input" data-type="any"></flow-socket>
              <!-- Custom styled socket -->
              <flow-socket type="output" name="custom" label="Custom Output" data-type="any" size="20px"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Square Sample Node with Square Slots -->
        <flow-node-def name="shape.square" label="Square Slots" width="160" height="160" category="Shapes" description="Shows square-shaped sockets" icon="‚¨ú" 
                       color-bg="linear-gradient(90deg, rgba(16,185,129,0.15), transparent)" color-text="#10b981" onExecute="generateSquare">
          <node-body>
            <div class="title">‚¨ú Square Slots</div>
            <div class="body">
              <!-- Square visualization -->
              <div style="width: 60px; height: 60px; background: linear-gradient(45deg, #10b981, #059669); border: 2px solid #10b981; border-radius: 4px; margin: 8px auto; box-shadow: 0 2px 8px rgba(16,185,129,0.3);"></div>
              
              <!-- Input controls -->
              <div style="margin: 8px 0;">
                <label style="font-size: 10px; color: rgba(255,255,255,0.7);">Size:</label>
                <input type="range" min="10" max="100" value="50" data-key="size" data-draggable="false" style="width: 100%; accent-color: #10b981;">
              </div>
              
              <!-- Default circular sockets -->
              <flow-socket type="input" name="size" label="Size" data-type="number" size="16px"></flow-socket>
              <flow-socket type="output" name="shape" label="Shape" data-type="object" size="20px" custom-class="glow-effect"></flow-socket>
              
              <!-- Square socket via custom slot content -->
              <flow-socket type="output" name="square" data-type="any">
                <flow-socket-anchor>
                  <span style="border-color: #10b981; background: linear-gradient(45deg, #10b981, #059669); width: 18px; height: 18px; border-radius: 4px; display: block; border: 2px solid;"></span>
                </flow-socket-anchor>
                <span class="socket-label" style="color: #10b981; font-weight: bold;">Square Socket</span>
              </flow-socket>
              
              <!-- Diamond socket via custom slot content -->
              <flow-socket type="input" name="diamond" data-type="any">
                <flow-socket-anchor>
                  <span style="border-color: #8b5cf6; background: linear-gradient(45deg, #8b5cf6, #7c3aed); width: 24px; height: 24px; display: block; border: 2px solid; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); margin: 0 auto;"></span>
                </flow-socket-anchor>
                <span class="socket-label" style="color: #8b5cf6; font-weight: bold;">Diamond Socket</span>
              </flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Custom Styled Node Examples - Demonstrates the new node customization system -->
        
        <!-- Solid Opaque Node -->
        <flow-node-def name="custom.minimal" label="Solid Node" width="250" height="140" category="Custom" description="Pure opaque solid design with auto-expanding textbox" icon="üî≤" 
                       custom-class="node-solid" onExecute="minimalExample">
          <node-body>
            <div class="">üî≤ Solid Design</div>
            <div class="body">
              <flow-socket type="input" name="input" label="Input" data-type="any"></flow-socket>
              <div style="margin: 8px 0;">
                <input type="text" class="input-box auto-expand" value="Solid & Opaque" data-key="text:value" placeholder="Enter text" style="width: calc(100% - 10px); min-width: 200px;">
              </div>
              <flow-socket type="output" name="output" label="Output" data-type="any"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        <!-- Dynamic Socket Node - Demonstrates runtime socket creation/removal -->
        <flow-node-def name="dynamic.sockets" label="Dynamic Sockets" width="200" height="140" category="Dynamic" description="Add/remove sockets at runtime" icon="‚ö°" 
                       color-bg="linear-gradient(90deg, rgba(16,185,129,0.15), transparent)" color-text="#10b981" onExecute="dynamicSocketExample">
          <node-body>
            <div class="title">‚ö° Dynamic Sockets</div>
            <div class="body">
              <!-- Initial socket -->
              <flow-socket type="input" name="input1" label="Input 1" data-type="any"></flow-socket>
              
              <!-- Control buttons -->
              <div style="margin: 8px 0; display: flex; gap: 4px; flex-wrap: wrap;">
                <button class="socket-control-btn" data-action="add-input" style="font-size: 10px; padding: 2px 6px; background: #10b981; color: white; border: none; border-radius: 3px; cursor: pointer;">+ Input</button>
                <button class="socket-control-btn" data-action="add-output" style="font-size: 10px; padding: 2px 6px; background: #3b82f6; color: white; border: none; border-radius: 3px; cursor: pointer;">+ Output</button>
                <button class="socket-control-btn" data-action="remove-last" style="font-size: 10px; padding: 2px 6px; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer;">- Last</button>
              </div>
              
              <!-- Initial output -->
              <flow-socket type="output" name="output1" label="Output 1" data-type="any" color="#10b981"></flow-socket>
            </div>
          </node-body>
        </flow-node-def>
        
        
      </flow-definitions>
      
      <flow-nodes>
        <!-- Create more example nodes: multiple numbers, operations, and watch nodes -->
        <flow-node type="data.number" id="n1" x="100" y="100"></flow-node>
        <flow-node type="data.number" id="n2" x="100" y="250"></flow-node>
        <flow-node type="data.number" id="n3" x="100" y="400"></flow-node>
        <flow-node type="math.add" id="n4" x="350" y="175"></flow-node>
        <flow-node type="math.multiply" id="n5" x="350" y="400"></flow-node>
        <flow-node type="logic.if" id="n6" x="600" y="175"></flow-node>
        <flow-node type="logic.if" id="n7" x="600" y="400"></flow-node>
        <flow-node type="data.watch" id="n8" x="850" y="100"></flow-node>
        <flow-node type="data.watch" id="n9" x="850" y="250"></flow-node>
        <flow-node type="data.watch" id="n10" x="850" y="400"></flow-node>
        <flow-node type="data.watch" id="n11" x="850" y="550"></flow-node>
        <!-- Test node with new flow-socket system -->
        <flow-node type="example.custom" id="n12" x="100" y="550"></flow-node>
        <!-- Square sample node -->
        <flow-node type="shape.square" id="n13" x="300" y="550"></flow-node>
        
        <!-- Custom styled node - demonstrating the new node customization system -->
        <flow-node type="custom.minimal" id="n14" x="500" y="550"></flow-node>
        
        <!-- Dynamic socket node - demonstrates runtime socket creation/removal -->
        <flow-node type="dynamic.sockets" id="n15" x="700" y="550"></flow-node>
      </flow-nodes>
      
      <flow-edges>
        <!-- Connect all nodes: multiple numbers -> operations -> if-branches -> watch nodes -->
        <flow-edge from="n1:value" to="n4:a"></flow-edge>
        <flow-edge from="n2:value" to="n4:b"></flow-edge>
        <flow-edge from="n2:value" to="n5:a"></flow-edge>
        <flow-edge from="n3:value" to="n5:b"></flow-edge>
        <flow-edge from="n4:sum" to="n6:condition"></flow-edge>
        <flow-edge from="n5:product" to="n7:condition"></flow-edge>
        <flow-edge from="n6:true" to="n8:value"></flow-edge>
        <flow-edge from="n6:false" to="n9:value"></flow-edge>
        <flow-edge from="n7:true" to="n10:value"></flow-edge>
        <flow-edge from="n7:false" to="n11:value"></flow-edge>
        <!-- Test edge with new flow-socket system -->
        <flow-edge from="n3:value" to="n12:default"></flow-edge>
      </flow-edges>
    </flow-graph>
  </div>
  
  <script type="module">
    // Wait for custom elements to be defined
    await customElements.whenDefined('flow-graph');
    
    // Example of programmatic API usage
    const flowGraphElement = document.querySelector('flow-graph');
    
    flowGraphElement.addEventListener('node:create', (e) => {
      //console.log('Node created:', e.detail.node);
    });
    
    flowGraphElement.addEventListener('edge:create', (e) => {
      //console.log('Edge created:', e.detail.edge);
    });
    
    
    // Node selection events
    flowGraphElement.addEventListener('node:select', (e) => {
      //console.log('üéØ Node selected:', e.detail.nodeId, 'Selection:', e.detail.selection);
    });
    
    flowGraphElement.addEventListener('node:deselect', (e) => {
      //console.log('‚ùå Node deselected:', e.detail.nodeId, 'Selection:', e.detail.selection);
    });
    
    flowGraphElement.addEventListener('selection:clear', (e) => {
      //console.log('üßπ Selection cleared, previous:', e.detail.previousSelection);
    });
    
    // Node movement events
    flowGraphElement.addEventListener('node:move', (e) => {
      //console.log('üöÄ Node moved:', e.detail.nodeId, 
      //  'from', e.detail.oldPosition, 'to', e.detail.newPosition);
    });
    
    // Edge selection events
    flowGraphElement.addEventListener('edge:select', (e) => {
      //console.log('üîó Edge selected:', e.detail.edgeId);
    });
    
    flowGraphElement.addEventListener('edge:deselect', (e) => {
      //console.log('üîó Edge deselected:', e.detail.edgeId);
    });

    flowGraphElement.addEventListener('edge:connection:failed', (e) => {
        //console.log('‚ùå Connection failed:', e.detail.reason);
    });
    
    // Viewport events
    flowGraphElement.addEventListener('viewport:change', (e) => {
      //console.log('üìê Viewport changed:', e.detail);
    });
    
    flowGraphElement.addEventListener('viewport:zoom', (e) => {
      //console.log('üîç Zoomed to:', e.detail.scale);
    });
    
    flowGraphElement.addEventListener('viewport:pan', (e) => {
      //console.log('üëÜ Panned to:', e.detail.x, e.detail.y);
    });
    
    // Keyboard shortcut events
    flowGraphElement.addEventListener('selection:change', (e) => {
      //console.log('üìã Selection changed:', e.detail.selectedNodes.length, 'nodes selected');
    });
    
    flowGraphElement.addEventListener('nodes:copy', (e) => {
      //console.log('üìã Nodes copied:', e.detail.copiedNodes.length, 'nodes,', e.detail.copyData.edges.length, 'edges');
    });
    
    flowGraphElement.addEventListener('nodes:paste', (e) => {
      //console.log('üìã Nodes pasted:', e.detail.pastedNodes.length, 'nodes');
    });
    
    flowGraphElement.addEventListener('nodes:delete', (e) => {
      //console.log('üóëÔ∏è Nodes deleted:', e.detail.deletedNodes.length, 'nodes,', e.detail.deletedEdges.length, 'edges');
    });
    
    // Node execution events
    flowGraphElement.addEventListener('node:execute', (e) => {
      //console.log('‚ö° Node executed:', e.detail.nodeId);
    });
    
    flowGraphElement.addEventListener('node:execute:error', (e) => {
      //console.error('‚ùå Node execution error:', e.detail.nodeId, 'Error:', e.detail.error);
    });
    
    // Graph execution events
    flowGraphElement.addEventListener('graph:execute:start', (e) => {
      console.log('üöÄ Graph execution started');
    });
    
    flowGraphElement.addEventListener('graph:execute:complete', (e) => {
      console.log('‚úÖ Graph execution completed');
    });
    
    // Execute graph button
    document.getElementById('execute-graph-btn').addEventListener('click', async () => {
      console.log('üöÄ Executing entire graph...');
      await flowGraphElement.flowGraph.execute();
    });
    
    
    // Wait for the component to be fully initialized
    const waitForFlowGraph = () => {
      return new Promise((resolve) => {
        if (flowGraphElement.flowGraph && flowGraphElement.flowGraph.nodes) {
          resolve();
        } else {
          setTimeout(() => waitForFlowGraph().then(resolve), 50);
        }
      });
    };

    await waitForFlowGraph();
    console.log('FlowGraph loaded with', flowGraphElement.flowGraph.nodes.size, 'nodes');
    
    // Add programmatic node template to test context menu
    flowGraphElement.flowGraph.addNodeTemplate('programmatic.test', {
      name: 'programmatic.test',
      label: 'Programmatic Test',
      category: 'Programmatic',
      icon: 'üß™',
      description: 'Added via addNodeTemplate() - should appear in context menu',
      inputs: [
        { id: 'input1', label: 'Input 1', type: 'any' },
        { id: 'input2', label: 'Input 2', type: 'any' }
      ],
      outputs: [
        { id: 'output1', label: 'Output 1', type: 'any' },
        { id: 'output2', label: 'Output 2', type: 'any' }
      ],
      html: `
        <node-body>
          <div class="title">üß™ Programmatic Test</div>
          <div class="body">
            <flow-socket type="input" name="input1" label="Input 1"></flow-socket>
            <flow-socket type="input" name="input2" label="Input 2"></flow-socket>
            <div style="height:8px"></div>
            <flow-socket type="output" name="output1" label="Output 1"></flow-socket>
            <flow-socket type="output" name="output2" label="Output 2"></flow-socket>
          </div>
        </node-body>
      `
    });
    
    console.log('Added programmatic node template. Available templates:', Array.from(flowGraphElement.flowGraph.templates.keys()));
    
    // Setup auto-expand for custom nodes
    function setupAutoExpand() {
      const autoExpandInputs = document.querySelectorAll('.auto-expand');
      
      autoExpandInputs.forEach((input) => {
        // Remove existing listeners to avoid duplicates
        if (input._autoExpandHandler) {
          input.removeEventListener('input', input._autoExpandHandler);
        }
        
        // Create new handler
        input._autoExpandHandler = () => {
          const width = Math.max(input.value.length * 8 + 20, 200);
          input.style.width = `${width}px`;
          // Edges will automatically update via ResizeObserver
        };
        
        // Add the listener
        input.addEventListener('input', input._autoExpandHandler);
        
        // Also trigger initial sizing based on current value
        if (input.value) {
          const width = Math.max(input.value.length * 8 + 20, 200);
          input.style.width = `${width}px`;
        }
      });
    }
    
    // Initial setup
    setupAutoExpand();
    
    // Setup auto-expand for nodes created after deserialization
    flowGraphElement.flowGraph.addEventListener('node:create', () => {
      // Small delay to ensure DOM is ready
      setTimeout(setupAutoExpand, 0);
    });
    
    // Setup auto-expand after deserialization
    flowGraphElement.flowGraph.addEventListener('graph:deserialize', () => {
      // Small delay to ensure all nodes are created
      setTimeout(setupAutoExpand, 0);
    });
    
    // Also try listening on the container element
    flowGraphElement.flowGraph.container.addEventListener('graph:deserialize', () => {
      setTimeout(setupAutoExpand, 0);
    });
    
    // Fallback: Try to setup auto-expand after a delay to catch any missed events
    setTimeout(() => {
      setupAutoExpand();
    }, 500);
    
    // Setup socket control event handlers for dynamic socket nodes
    function setupSocketControls() {
      const socketControlBtns = document.querySelectorAll('.socket-control-btn');
      
      socketControlBtns.forEach((btn) => {
        // Remove any existing listeners by cloning the button
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        
        newBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation(); // Prevent node dragging
          
          const action = newBtn.getAttribute('data-action');
          
          // Find the node element using multiple strategies
          let nodeElement = newBtn.closest('.flow-node') || 
                           newBtn.closest('[data-id]') ||
                           findNodeByButton(newBtn);
          
          if (!nodeElement) return;
          
          // Find the node instance
          const nodeId = nodeElement.id || nodeElement.getAttribute('data-id');
          const node = flowGraphElement.flowGraph?.nodes.get(nodeId);
          
          if (!node) return;
          
          // Execute the action
          switch (action) {
            case 'add-input':
              addDynamicSocket(node, 'input');
              break;
            case 'add-output':
              addDynamicSocket(node, 'output');
              break;
            case 'remove-last':
              removeLastDynamicSocket(node);
              break;
          }
        });
      });
    }
    
    // Helper function to find node by button element
    function findNodeByButton(button) {
      let current = button.parentElement;
      while (current) {
        if (current.hasAttribute('data-id')) {
          return current;
        }
        current = current.parentElement;
      }
      
      // Fallback: search all nodes
      const allNodes = document.querySelectorAll('[data-id]');
      for (const node of allNodes) {
        if (node.querySelector('.socket-control-btn') === button) {
          return node;
        }
      }
      return null;
    }
    
    // Function to add a dynamic socket
    function addDynamicSocket(node, type) {
      try {
        const socketCount = type === 'input' ? node.inputs.size : node.outputs.size;
        const socketId = `${type}${socketCount + 1}`;
        const label = `${type === 'input' ? 'Input' : 'Output'} ${socketCount + 1}`;
        
        const socket = node.addSocket({
          id: socketId,
          type: type,
          dataType: 'any',
          label: label,
          color: type === 'input' ? '#10b981' : '#3b82f6'
        });
        
        // Wait for DOM to update, then show visual feedback and re-setup controls
        setTimeout(() => {
          if (socket.element) {
            socket.element.style.transform = 'scale(1.2)';
            setTimeout(() => {
              socket.element.style.transform = 'scale(1)';
            }, 200);
          }
          
          // Re-setup socket controls to ensure they work with updated DOM
          setupSocketControls();
        }, 100);
        
      } catch (error) {
        console.error(`Error adding ${type} socket:`, error);
      }
    }
    
    // Function to remove the last dynamic socket
    function removeLastDynamicSocket(node) {
      try {
        // Find the last socket (highest numbered)
        let lastSocketId = null;
        let lastSocketType = null;
        let maxNumber = 0;
        
        // Check input sockets
        for (const [socketId] of node.inputs) {
          const match = socketId.match(/^input(\d+)$/);
          if (match) {
            const number = parseInt(match[1]);
            if (number > maxNumber) {
              maxNumber = number;
              lastSocketId = socketId;
              lastSocketType = 'input';
            }
          }
        }
        
        // Check output sockets
        for (const [socketId] of node.outputs) {
          const match = socketId.match(/^output(\d+)$/);
          if (match) {
            const number = parseInt(match[1]);
            if (number > maxNumber) {
              maxNumber = number;
              lastSocketId = socketId;
              lastSocketType = 'output';
            }
          }
        }
        
        if (lastSocketId && lastSocketType) {
          const removed = node.removeSocket(lastSocketId, lastSocketType);
          if (removed) {
            // Re-setup socket controls after removal
            setTimeout(() => {
              setupSocketControls();
            }, 100);
          }
        }
      } catch (error) {
        console.error('Error removing socket:', error);
      }
    }
    
    // Setup socket controls when nodes are created
    flowGraphElement.flowGraph.addEventListener('node:create', () => {
      setTimeout(setupSocketControls, 200);
    });
    
    // Use event delegation as a fallback
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('socket-control-btn')) {
        e.preventDefault();
        e.stopPropagation();
        
        const action = e.target.getAttribute('data-action');
        const nodeElement = e.target.closest('.flow-node') || 
                           e.target.closest('[data-id]') ||
                           findNodeByButton(e.target);
        
        if (!nodeElement) return;
        
        // Find the node instance
        const nodeId = nodeElement.id || nodeElement.getAttribute('data-id');
        const node = flowGraphElement.flowGraph?.nodes.get(nodeId);
        
        if (!node) return;
        
        // Execute the action
        switch (action) {
          case 'add-input':
            addDynamicSocket(node, 'input');
            break;
          case 'add-output':
            addDynamicSocket(node, 'output');
            break;
          case 'remove-last':
            removeLastDynamicSocket(node);
            break;
        }
      }
    });
    
    // Initial setup
    setTimeout(setupSocketControls, 500);
    setTimeout(setupSocketControls, 1000);
    
    
    // Async onExecuteMethod functions for all flow-node-def elements
    // Make functions globally accessible
    window.loadData = async function(context) {
      console.log('üî¢ Loading data for Number node:', context);
      
      // Use the new data binding system
      const value = parseInt(context.getData('num')) || 0;
      
      // Simulate async data loading
      await new Promise(resolve => setTimeout(resolve,1000));
      
      console.log('Number value:', value);
      
      // Set output value (index 0 for first output socket)
      context.setOutput(0, value);
    };
    
    window.addNumbers = async function(context) {
      console.log('‚ûï Adding numbers:', context);
      
      // Get input values using index (a=0, b=1)
      const a = context.getInput(0) || 0;
      const b = context.getInput(1) || 0;
      
      // Simulate async calculation
      await new Promise(resolve => setTimeout(resolve,1000));
      
      const sum = a + b;
      console.log(`Adding ${a} + ${b} = ${sum}`);
      
      // Set output value (index 0 for first output socket)
      context.setOutput(0, sum);
    };
    
    window.watchValue = async function(context) {
      console.log('üëÅÔ∏è Watching value:', context);
      
      // Get input value (index 0 for first input socket)
      const value = context.getInput(0);
      
      // Simulate async value processing
      await new Promise(resolve => setTimeout(resolve,1000));
      
      console.log('Watched value:', value);
    };
    
    window.multiplyNumbers = async function(context) {
      console.log('‚úñÔ∏è Multiplying numbers:', context);
      
      // Get input values (a=0, b=1)
      const a = context.getInput(0) || 1;
      const b = context.getInput(1) || 1;
      
      // Simulate async calculation
      await new Promise(resolve => setTimeout(resolve,1000));
      
      const product = a * b;
      console.log(`Multiplying ${a} * ${b} = ${product}`);
      
      // Set output value (index 0 for first output socket)
      context.setOutput(0, product);
    };
    
    window.splitValue = async function(context) {
      console.log('üîÄ Splitting value:', context);
      
      // Get input value (index 0 for first input socket)
      const input = context.getInput(0);
      
      // Simulate async value splitting
      await new Promise(resolve => setTimeout(resolve,1000));
      
      // Set multiple output values (out1=0, out2=1, out3=2)
      context.setOutput(0, input); // out1
      context.setOutput(1, input); // out2
      context.setOutput(2, input); // out3
    };
    
    window.render3D = async function(context) {
      console.log('üé® Rendering 3D:', context);
      
      // Get input values
      const meshData = context.getInput(0);
      const camera = context.getInput(1);
      
      // Simulate async 3D rendering
      await new Promise(resolve => setTimeout(resolve,1000));
      
      // Set output values
      context.setOutput(0, '3D rendered content'); // render
      context.setOutput(1, { fps: 60, triangles: 1000 }); // stats
    };
    
    window.conditionalLogic = async function(context) {
      console.log('‚ö° Processing conditional logic:', context);
      
      // Get input value (sum from previous node)
      const sum = context.getInput(0);
      const condition = sum > 10; // True if sum is greater than 10
      
      console.log(`‚ö° Condition: ${sum} > 10 = ${condition}`);
      
      // Simulate async condition evaluation
      await new Promise(resolve => setTimeout(resolve,1000));
      
      // Only set the active branch output, leave the other branch unset
      if (condition) {
        console.log('‚ö° Taking TRUE branch - sum is greater than 10');
        context.setOutput(0, `TRUE: ${sum} > 10`); // true branch only
        console.log('‚ö° Set TRUE branch output, FALSE branch left unset');
        // Don't set false branch - leave it unexecuted
      } else {
        console.log('‚ö° Taking FALSE branch - sum is 10 or less');
        // Don't set true branch - leave it unexecuted
        context.setOutput(1, `FALSE: ${sum} <= 10`); // false branch only
        console.log('‚ö° Set FALSE branch output, TRUE branch left unset');
      }
    };
    
    window.processString = async function(context) {
      console.log('üìù Processing string:', context);
      
      // Use the new data binding system
      const text = context.getData('text') || '';
      
      // Simulate async string processing
      await new Promise(resolve => setTimeout(resolve,1000));
      
      console.log('Processed text:', text);
      
      // Set output value
      context.setOutput(0, text);
    };
    
    window.renderCanvas = async function(context) {
      console.log('üé® Rendering canvas:', context);
      
      // Simulate async canvas rendering
      await new Promise(resolve => setTimeout(resolve,1000));
      
      // Set output value
      context.setOutput(0, 'canvas rendered image data');
    };
    
    window.customExample = async function(context) {
      console.log('üé® Custom socket example:', context);
      
      // Simulate async processing
      await new Promise(resolve => setTimeout(resolve,1000));
      
      // Set output value
      context.setOutput(0, 'Custom socket output!');
    };
    
    window.generateSquare = async function(context) {
      console.log('‚¨ú Generating square:', context);
      
      // Get size from input or data binding
      const size = context.getInput(0) || context.getData('size') || 50;
      
      // Simulate async processing
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Create square shape object
      const square = {
        type: 'square',
        size: size,
        color: '#10b981',
        position: { x: 0, y: 0 },
        rotation: 0,
        properties: {
          width: size,
          height: size,
          borderWidth: 2,
          borderRadius: 4
        }
      };
      
      // Set output value
      context.setOutput(0, square);
      
      console.log('‚úÖ Square generated:', square);
    };
    
    // Custom node execution functions - demonstrating the new customization system
    
    window.minimalExample = async function(context) {
      console.log('‚ú® Minimal node example:', context);
      
      // Get input value or use data binding
      const inputValue = context.getInput(0) || context.getData('text') || 'Clean & Simple';
      
      // Simulate processing
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Process the input (simple text transformation)
      const result = `Processed: ${inputValue}`;
      
      // Set output value
      context.setOutput(0, result);
      
      console.log('‚úÖ Minimal processing complete:', result);
    };
    
    // Dynamic Socket Node execution function
    window.dynamicSocketExample = async function(context) {
      console.log('‚ö° Dynamic socket example:', context);
      
      // Get input values from all input sockets
      const inputValues = [];
      for (let i = 0; i < context.inputs.size; i++) {
        inputValues.push(context.getInput(i));
      }
      
      // Simulate processing
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Process all inputs and set all outputs
      const result = `Processed ${inputValues.length} inputs`;
      
      // Set output values for all output sockets
      for (let i = 0; i < context.outputs.size; i++) {
        context.setOutput(i, `${result} - Output ${i + 1}`);
      }
      
      console.log('‚úÖ Dynamic socket processing complete:', result);
    };
    
    
    // Animation Controls
    let animationsEnabled = true;
    const animationStyleSelect = document.getElementById('animation-style');
    const animationSpeedSelect = document.getElementById('animation-speed');
    const toggleAnimationsBtn = document.getElementById('toggle-animations');
    const clearTrailBtn = document.getElementById('clear-trail');
    const resetColorsBtn = document.getElementById('reset-colors');
    const trailDurationSelect = document.getElementById('trail-duration');
    
    // Update animation configuration
    function updateAnimationConfig() {
      if (flowGraphElement.flowGraph) {
        flowGraphElement.flowGraph.setAnimationConfig({
          enabled: animationsEnabled,
          style: animationStyleSelect.value,
          speed: animationSpeedSelect.value
        });
      } else {
        console.warn('FlowGraph instance not available yet');
      }
    }
    
    // Update trail duration
    function updateTrailDuration() {
      if (flowGraphElement.flowGraph) {
        const duration = parseInt(trailDurationSelect.value);
        flowGraphElement.flowGraph.setTrailDuration(duration);
        console.log(`‚è±Ô∏è Trail duration set to ${duration}ms`);
      } else {
        setTimeout(updateTrailDuration, 100);
      }
    }
    
    // Toggle animations
    toggleAnimationsBtn.addEventListener('click', () => {
      animationsEnabled = !animationsEnabled;
      toggleAnimationsBtn.textContent = animationsEnabled ? 'Disable' : 'Enable';
      toggleAnimationsBtn.style.background = animationsEnabled 
        ? 'linear-gradient(135deg, #7c3aed, #5b21b6)' 
        : 'linear-gradient(135deg, #6b7280, #4b5563)';
      updateAnimationConfig();
    });
    
    // Update config when style or speed changes
    animationStyleSelect.addEventListener('change', updateAnimationConfig);
    animationSpeedSelect.addEventListener('change', updateAnimationConfig);
    trailDurationSelect.addEventListener('change', updateTrailDuration);
    
    // Clear trail button
    clearTrailBtn.addEventListener('click', () => {
      if (flowGraphElement.flowGraph) {
        flowGraphElement.flowGraph.clearExecutionTrail();
      }
    });
    
    // Reset colors button
    resetColorsBtn.addEventListener('click', () => {
      if (flowGraphElement.flowGraph) {
        flowGraphElement.flowGraph.resetAllEdgeColors();
      }
    });
    
    // Save graph button
    document.getElementById('save-graph').addEventListener('click', () => {
      if (flowGraphElement.flowGraph) {
        try {
          const graphData = flowGraphElement.flowGraph.serialize();
          const dataStr = JSON.stringify(graphData, null, 2);
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `flowgraph_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          
          console.log('üíæ Graph saved successfully!');
        } catch (error) {
          console.error('‚ùå Error saving graph:', error);
        }
      }
    });
    
    // Load graph button
    document.getElementById('load-graph').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const graphData = JSON.parse(e.target.result);
              if (flowGraphElement.flowGraph) {
                flowGraphElement.flowGraph.deserialize(graphData);
              } else {
                // Wait for FlowGraph to be ready
                const waitForFlowGraph = () => {
                  if (flowGraphElement.flowGraph) {
                    flowGraphElement.flowGraph.deserialize(graphData);
                  } else {
                    setTimeout(waitForFlowGraph, 100);
                  }
                };
                waitForFlowGraph();
              }
            } catch (error) {
              console.error('‚ùå Error loading graph:', error);
              alert('Error loading graph file. Please check the file format.');
            }
          };
          reader.readAsText(file);
        }
      };
      input.click();
    });
    
    // Readonly toggle button
    const readonlyBtn = document.getElementById('toggle-readonly');
    let isReadonly = false;
    
    readonlyBtn.addEventListener('click', () => {
      // Wait for FlowGraph to be ready
      if (!flowGraphElement.flowGraph) {
        console.warn('FlowGraph not ready yet, please wait...');
        return;
      }
      
      isReadonly = !isReadonly;
      flowGraphElement.setReadonly(isReadonly);
      
      // Update button appearance
      if (isReadonly) {
        readonlyBtn.textContent = 'Exit Readonly';
        readonlyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        console.log('üîí Readonly mode enabled - editing is disabled');
      } else {
        readonlyBtn.textContent = 'Readonly Mode';
        readonlyBtn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
        console.log('üîì Readonly mode disabled - editing is enabled');
      }
    });
    
    // Initialize animation config after a short delay to ensure FlowGraph is ready
    setTimeout(() => {
      updateAnimationConfig();
      updateTrailDuration();
    }, 100);
  </script>
</body>
</html>
